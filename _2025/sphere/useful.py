from manim_imports_custom import *
def smooth_decay(t):
    return np.sin(6 * PI * t) * np.exp(-5 * t**1.5)
def get_special_dot(
    color=YELLOW,
    radius=0.07,
    glow_radius_multiple=3,
    glow_factor=1.5
):
    return Group(
        TrueDot(radius=radius).make_3d(),
        GlowDot(radius=radius * glow_radius_multiple, glow_factor=glow_factor)
    ).set_color(color)
class CylinderCustom(ParametricSurface):
    def __init__(
        self, 
        radius=1.0, 
        height=2.0,
        axis=OUT,
        **kwargs):
        self.radius = float(radius)
        self.height = float(height)
        self.axis=axis
        super().__init__(
            # u: height ∈ [0, height], v: angle ∈ [0, 2π]
            lambda u, v: (radius*np.cos(u), radius*np.sin(u), v),
            (0, TAU),(0, height), 
            **kwargs
        )
    def get_top_cap(self):
        top=Disk3DPatched(r_range=(0,self.radius)).set_z(self.height)
        self.top_cap=top
        return top
    def get_bottom_cap(self):
        bottom=Disk3DPatched(r_range=(0,self.radius)).invert_normals().set_z(0)
        self.bottom_cap=bottom
        return bottom
    def init_points(self):
        super().init_points()
        self.apply_matrix(z_to_vector(self.axis))
class Disk3DPatched(ParametricSurface):
    def __init__(
        self,
        r_range=(0,1),
        theta_range=(0, 2*PI),
        **kwargs):
        super().__init__(
            # 极坐标参数化
            lambda u, v: (u*np.cos(v), u*np.sin(v), 0.0),
            r_range,theta_range,
            **kwargs
        )

    @Mobject.affects_data
    def init_points(self):
        dim = self.dim
        nu, nv = self.resolution
        u_range = np.linspace(*self.u_range, nu)
        v_range = np.linspace(*self.v_range, nv)

        # Get three lists:
        # - Points generated by pure uv values
        # - Those generated by values nudged by du
        # - Those generated by values nudged by dv
        uv_grid = np.array([[[u, v] for v in v_range] for u in u_range])
        uv_plus_du = uv_grid.copy()
        uv_plus_du[:, :, 0] += self.epsilon
        uv_plus_dv = uv_grid.copy()
        uv_plus_dv[:, :, 1] += self.epsilon

        points, du_points, dv_points = [
            np.apply_along_axis(
                lambda p: self.uv_func(*p), 2, grid
            ).reshape((nu * nv, dim))
            for grid in (uv_grid, uv_plus_du, uv_plus_dv)
        ]
        # （保持原结构）用有限差分近似切向量 → 叉积法线
        crosses = np.cross(du_points - points, dv_points - points)  # NEW: 用 np.cross 更稳
        normals = normalize_along_axis(crosses, 1)

        # NEW: 修补奇点（r≈0 或法线出现非数）
        r_xy = np.linalg.norm(points[:, :2], axis=1)        # 半径
        bad = (r_xy < 1e-8) | ~np.isfinite(normals).all(1)  # 中心退化或法线异常
        if np.any(bad):
            normals[bad] = np.array([0.0, 0.0, 1.0])        # 指定 +Z 方向

        self.set_points(points)
        self.data['d_normal_point'] = points + self.normal_nudge * normals
    

        
class ConePatched(ParametricSurface):
    def __init__(
        self, 
        radius=1.0, 
        height=2.0,
        **kwargs):
        u_range=(0,height)
        v_range=(0,2*PI)
        self.radius = float(radius)
        self.height = float(height)

        super().__init__(
        # u: height, v: angle
        lambda u, v: (
            (radius * (height - v) / height) * np.cos(u),
            (radius * (height - v) / height) * np.sin(u),
            v
        ),
        v_range,u_range, 
        **kwargs
        )
    def get_bottom_cap(self):
        bottom=Disk3DPatched().invert_normals()
        self.bottom_cap=bottom
        return bottom
    @Mobject.affects_data
    def init_points(self):
        dim = self.dim
        nu, nv = self.resolution
        u_range = np.linspace(*self.u_range, nu)
        v_range = np.linspace(*self.v_range, nv)

        # Get three lists:
        # - Points generated by pure uv values
        # - Those generated by values nudged by du
        # - Those generated by values nudged by dv
        uv_grid = np.array([[[u, v] for v in v_range] for u in u_range])
        uv_plus_du = uv_grid.copy()
        uv_plus_du[:, :, 0] += self.epsilon
        uv_plus_dv = uv_grid.copy()
        uv_plus_dv[:, :, 1] += self.epsilon

        points, du_points, dv_points = [
            np.apply_along_axis(
                lambda p: self.uv_func(*p), 2, grid
            ).reshape((nu * nv, dim))
            for grid in (uv_grid, uv_plus_du, uv_plus_dv)
        ]
        crosses = np.cross(du_points - points, dv_points - points)
        normals = normalize_along_axis(crosses, 1)

        # NEW: 修补“尖点”法线（r≈0 或法线异常）
        r_xy = np.linalg.norm(points[:, :2], axis=1)
        bad = (r_xy < 1e-8) | ~np.isfinite(normals).all(1)
        if np.any(bad):
            normals[bad] = np.array([0.0, 0.0, 1.0])  # 也可用指向侧面的平均法线，简化起见设 +Z

        self.set_points(points)
        
        self.data['d_normal_point'] = points + self.normal_nudge * normals